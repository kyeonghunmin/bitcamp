// @Component, @Controller가 붙은 클래스에 대해서만 
// 인스턴스를 생성하고 관리한다.
package bitcamp.pms.context;

import java.io.File;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import bitcamp.pms.annotation.Component;
import bitcamp.pms.annotation.Controller;

public class ApplicationContext {
  HashMap<String, Object> objPool = new HashMap<>();

  public ApplicationContext(String basePackage) {
    String path = "./bin/" + basePackage.replace(".", "/");
    createObject(new File(path)); // path = ./bin/bitcamp/pms
    injectDependency();
  }

  private void injectDependency() {
    Collection<Object> objects = objPool.values();
    Class<?> clazz = null;
    Method[] methods = null;
    Class<?> paramType = null;
    Object dependency = null;
    for (Object obj : objects) {
      clazz = obj.getClass();
      // System.out.println(clazz);
      /*class bitcamp.pms.controller.BoardListController
      class bitcamp.pms.dao.ProjectDao ....*/

      methods = clazz.getMethods();
      for (Method m : methods) {
        if (!m.getName().startsWith("set")) 
          continue; // Dao를 다 튕긴다.

        paramType = m.getParameterTypes()[0];
        System.out.printf("--->%s(%s)\n", m.getName(), paramType.getName());
        dependency = findObjectByType(paramType);
        System.out.printf("--->%s(%s)\n", 
            findObjectByType(paramType), dependency.getName());

        if (dependency == null) // 셋터가 원하는 의존 객체를 찾지 못하면,
          continue;

        try {
          m.invoke(obj, dependency); // 셋터를 호출하여 의존 객체를 주입한다.
        } catch (Exception e) {}
      }
    }
  }

  private Object findObjectByType(Class<?> paramType) {
    Collection<Object> objects = objPool.values();
    for (Object obj : objects) {
      if (paramType.isInstance(obj)) {
        return obj;
      }
    }
    return null;
  }

  private void createObject(File file) {
    if (file.isFile() && file.getName().endsWith(".class")) {
      // System.out.println(file.getPath());
      String classNameWithPackage = file.getPath()
          .replace("./bin/", "").replace(".class", "").replace("/", ".");
      try {
        Class<?> clazz = Class.forName(classNameWithPackage);
        // forName() -> .class인 파일의 객체(여기선 file의 클래스 정보를 리턴)
        // ex> class bitcamp.pms.ProjectApp

        // @Component, @Controller 애노테이션 구분하여 처리
        Annotation[] annos = clazz.getAnnotations();
        
        for (Annotation anno : annos) {
          if (anno.annotationType() == Component.class) {
            // System.out.printf("%s --> %s\n", clazz.getName(), "Component");
            processComponentAnnotation(clazz);
            
          } else if (anno.annotationType() == Controller.class) {
            // System.out.printf("%s --> %s\n", clazz.getName(), "Controller");
            processControllerAnnotation(clazz);
          }
        }
      } catch (Exception e) {
        // 무시
        e.printStackTrace();
      }
      return;
    }

    File[] subfiles = file.listFiles();
    for (File subfile : subfiles) {
      createObject(subfile);
    }
  }
  
  private void processComponentAnnotation(Class<?> clazz) throws Exception{
    Component anno = clazz.getAnnotation(Component.class);
    String key = anno.value();
    if (key.equals("")) {
      key = clazz.getName();
      // System.out.println(key);
      /*bitcamp.pms.dao.BoardDao
      bitcamp.pms.dao.ProjectDao
      bitcamp.pms.dao.MemberDao*/
    }
    objPool.put(key, clazz.newInstance());
    /*System.out.println(clazz.newInstance());
    bitcamp.pms.dao.BoardDao@1d44bcfa
    bitcamp.pms.dao.ProjectDao@266474c2
    bitcamp.pms.dao.MemberDao@6f94fa3e*/
  }
  
  private void processControllerAnnotation(Class<?> clazz) throws Exception{
    Controller anno = clazz.getAnnotation(Controller.class);
    String key = anno.value();
    if (key.equals("")) {
      key = clazz.getName();
    }
    objPool.put(key, clazz.newInstance());
  }

  public List<Object> getBeans(Class<?> beanType) {
    ArrayList<Object> list = new ArrayList<>();
    Collection<Object> objects = objPool.values();
    for (Object obj : objects) {
      if (beanType.isInstance(obj)) {
        list.add(obj);
      }
    }
    return list;
  }

  public Object getBean(String name) {
    return objPool.get(name);
  }

  public Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annoType) {
    // 전체 객체 목록
    Set<Entry<String,Object>> entrySet = objPool.entrySet();
    // entrySet() = 키와 값을 한번에 뽑는다, 
    // Set은 키와 값을 한개로 해서 반복문을 돌릴 수 있다.
    
    // 특정 애노테이션이 붙은 객체 목록
    HashMap<String, Object> objMap = new HashMap<>();
    
    Object obj = null;
    for (Entry<String,Object> entry : entrySet) {
      obj = entry.getValue();
      if (obj.getClass().getAnnotation(annoType) == null) 
        continue;
      
      objMap.put(entry.getKey(), obj);
    }
    return objMap;
  }

  public Object getBean(Class<?> type) {
    Collection<Object> objects = objPool.values();
    for (Object obj : objects) {
      if (type.isInstance(obj)) {
        return obj;
      }
    }
    return null;
  }

  // 외부에서 임의로 객체를 추가할 수 있게 한다.
  public void addBean(String name, Object bean) {
    objPool.put(name, bean);
  }
  
}
